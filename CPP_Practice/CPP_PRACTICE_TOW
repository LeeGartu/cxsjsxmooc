{"test_title": "024:鸣人和佐助", "test_describe": null, "test_input": "输入的第一行包含三个整数：M，N，T。代表M行N列的地图和鸣人初始的查克拉数量T。0 < M,N < 200，0 ≤ T < 10", "test_output": "输出包含一个整数R，代表鸣人追上佐助最少需要花费的时间。如果鸣人无法追上佐助，则输出-1。", "demo_input": "样例输入1\r\n4 4 1\r\n#@##\r\n**##\r\n###+\r\n****\r\n\r\n样例输入2\r\n4 4 2\r\n#@##\r\n**##\r\n###+\r\n****", "demo_output": "样例输出1\r\n6\r\n\r\n样例输出2\r\n4"}
{"test_title": "020:棋盘问题", "test_describe": null, "test_input": "输入含有多组测试数据。", "test_output": "对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。", "demo_input": "2 1\r\n#.\r\n.#\r\n4 4\r\n...#\r\n..#.\r\n.#..\r\n#...\r\n-1 -1\r\n", "demo_output": "2\r\n1\r\n"}
{"test_title": "022:迷宫问题", "test_describe": null, "test_input": "一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。", "test_output": "左上角到右下角的最短路径，格式如样例所示。", "demo_input": "0 1 0 0 0\r\n0 1 0 1 0\r\n0 0 0 0 0\r\n0 1 1 1 0\r\n0 0 0 1 0", "demo_output": "(0, 0)\r\n(1, 0)\r\n(2, 0)\r\n(2, 1)\r\n(2, 2)\r\n(2, 3)\r\n(2, 4)\r\n(3, 4)\r\n(4, 4)"}
{"test_title": "017:分蛋糕", "test_describe": null, "test_input": "共有多行，每行表示一个测试案例。每行是三个用空格分开的整数w, h, m ，其中1 ≤ w, h, m ≤ 20 ， m ≤ wh. 当 w = h = m = 0 时不需要处理，表示输入结束。", "test_output": "每个测试案例的结果占一行，输出一个整数，表示最大蛋糕块的面积下限。", "demo_input": "4 4 4\r\n4 4 3\r\n0 0 0", "demo_output": "4\r\n6"}
{"test_title": "018:红与黑", "test_describe": null, "test_input": "包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下", "test_output": "对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。", "demo_input": "6 9 \r\n....#. \r\n.....# \r\n...... \r\n...... \r\n...... \r\n...... \r\n...... \r\n#@...# \r\n.#..#. \r\n0 0\r\n", "demo_output": "45\r\n"}
{"test_title": "014:最佳加法表达式", "test_describe": "给定n个1到9的数字，要求在数字之间摆放m个加号(加号两边必须有数字），使得所得到的加法表达式的值最小，并输出该值。例如，在1234中摆放1个加号，最好的摆法就是12+34,和为36", "test_input": "有不超过15组数据", "test_output": "对每组数据，输出最小加法表达式的值", "demo_input": "2\r\n123456\r\n1\r\n123456\r\n4\r\n12345\r\n", "demo_output": "102\r\n579\r\n15\r\n"}
{"test_title": "023:Pots", "test_describe": "You are given two pots, having the volume of ", "test_input": null, "test_output": null, "demo_input": "3 5 4", "demo_output": "6\r\nFILL(2)\r\nPOUR(2,1)\r\nDROP(1)\r\nPOUR(2,1)\r\nFILL(2)\r\nPOUR(2,1)"}
{"test_title": "021:鸣人和佐助", "test_describe": null, "test_input": "输入的第一行包含三个整数：M，N，T。代表M行N列的地图和鸣人初始的查克拉数量T。0 < M,N < 200，0 ≤ T < 10", "test_output": "输出包含一个整数R，代表鸣人追上佐助最少需要花费的时间。如果鸣人无法追上佐助，则输出-1。", "demo_input": "样例输入1\r\n4 4 1\r\n#@##\r\n**##\r\n###+\r\n****\r\n\r\n样例输入2\r\n4 4 2\r\n#@##\r\n**##\r\n###+\r\n****", "demo_output": "样例输出1\r\n6\r\n\r\n样例输出2\r\n4"}
{"test_title": "015:复杂的整数划分问题", "test_describe": null, "test_input": "标准的输入包含若干组测试数据。每组测试数据是一行输入数据,包括两个整数N 和 K。 ", "test_output": "对于每组测试数据，输出以下三行数据:", "demo_input": "5 2", "demo_output": "2\r\n3\r\n3"}
{"test_title": "016:Charm Bracelet", "test_describe": null, "test_input": "Line 1: Two space-separated integers: N and M", "test_output": "Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints", "demo_input": "4 6\r\n1 4\r\n2 6\r\n3 12\r\n2 7", "demo_output": "23"}
{"test_title": "010:输出前k大的数", "test_describe": "给定一个数组，统计前k大的数并且把这k个数从大到小输出。", "test_input": "第一行包含一个整数n，表示数组的大小。n < 100000。", "test_output": "从大到小输出前k大的数，每个数一行。", "demo_input": "10\r\n4 5 6 9 8 7 1 2 3 0\r\n5", "demo_output": "9\r\n8\r\n7\r\n6\r\n5"}
{"test_title": "008:派", "test_describe": "我的朋友们都特别小气，如果有人拿到更大的一块，就会开始抱怨。因此所有人拿到的派是同样大小的（但不需要是同样形状的），虽然这样有些派会被浪费，但总比搞砸整个派对好。当然，我也要给自己留一块，而这一块也要和其他人的同样大小。", "test_input": "第一行包含两个正整数N和F，1 ≤ N, F ≤ 10 000，表示派的数量和朋友的数量。", "test_output": "输出每个人能得到的最大的派的体积，精确到小数点后三位。", "demo_input": "3 3\r\n4 3 3", "demo_output": "25.133"}
{"test_title": "009:月度开销", "test_describe": "农夫约翰是一个精明的会计师。他意识到自己可能没有足够的钱来维持农场的运转了。他计算出并记录下了接下来 ", "test_input": "第一行包含两个整数N,M，用单个空格隔开。", "test_output": "一个整数，即最大月度开销的最小值。", "demo_input": "7 5\r\n100\r\n400\r\n300\r\n100\r\n500\r\n101\r\n400", "demo_output": "500"}
{"test_title": "006:简单的整数划分问题", "test_describe": null, "test_input": "标准的输入包含若干组测试数据。每组测试数据是一个整数N(0 < N <= 50)。", "test_output": "对于每组测试数据，输出N的划分数。", "demo_input": "5", "demo_output": "7"}
{"test_title": "011:求排列的逆序数", "test_describe": "在Internet上的搜索引擎经常需要对信息进行比较，比如可以通过某个人对一些事物的排名来估计他（或她）对各种不同信息的兴趣，从而实现个性化的服务。", "test_input": "第一行是一个整数n，表示该排列有n个数（n <= 100000)。", "test_output": "输出该排列的逆序数。", "demo_input": "6\r\n2 6 3 4 5 1", "demo_output": "8"}
{"test_title": "004:2的幂次方表示", "test_describe": "任何一个正整数都可以用2的幂次方表示。例如：", "test_input": "一个正整数n（n≤20000）。", "test_output": "一行，符合约定的n的0，2表示（在表示中不能有空格）。", "demo_input": "137", "demo_output": "2(2(2)+2+2(0))+2(2+2(0))+2(0)"}
{"test_title": "005:Boolean Expressions", "test_describe": null, "test_input": "The expressions are of a variable length, although will never exceed 100 symbols. Symbols may be separated by any number of spaces or no spaces at all, therefore, the total length of an expression, as a number of characters, is unknown. ", "test_output": "For each test expression, print \"Expression \" followed by its sequence number, \": \", and the resulting value of the corresponding test expression. Separate the output for consecutive test expressions with a new line. ", "demo_input": "( V | V ) & F & ( F| V)\r\n!V | V & V & !F & (F | V ) & (!F | F | !V & V)\r\n(F&F|V|!V&!F&!(F|F&V))", "demo_output": "Expression 1: F\r\nExpression 2: V\r\nExpression 3: V"}
{"test_title": "003:全排列", "test_describe": "给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 我们假设对于小写字母有'a' < 'b' < ... < 'y' < 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。 ", "test_input": "输入只有一行，是一个由不同的小写字母组成的字符串，已知字符串的长度在1到6之间。", "test_output": "输出这个字符串的所有排列方式，每行一个排列。要求字母序比较小的排列在前面。字母序如下定义：", "demo_input": "abc", "demo_output": "abc\r\nacb\r\nbac\r\nbca\r\ncab\r\ncba\r\n"}
{"test_title": "002:拨钟问题", "test_describe": "有9个时钟，排成一个3*3的矩阵。", "test_input": "9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。", "test_output": "输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。", "demo_input": "3 3 0 \r\n2 2 2 \r\n2 1 2 ", "demo_output": "4 5 8 9 "}
{"test_title": "001:特殊密码锁", "test_describe": "有一种特殊的二进制密码锁，由n个相连的按钮组成（n<30），按钮有凹/凸两种状态，用手按按钮会改变其状态。", "test_input": "两行，给出两个由0、1组成的等长字符串，表示当前/目标密码锁状态，其中0代表凹，1代表凸。", "test_output": "至少需要进行的按按钮操作次数，如果无法实现转变，则输出impossible。", "demo_input": "011\r\n000", "demo_output": "1"}
{"test_title": "013:Zipper", "test_describe": null, "test_input": "The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.", "test_output": "For each data set, print:", "demo_input": "3\r\ncat tree tcraete\r\ncat tree catrtee\r\ncat tree cttaree\r\n", "demo_output": "Data set 1: yes\r\nData set 2: yes\r\nData set 3: no\r\n"}
{"test_title": "007:Aggressive cows", "test_describe": null, "test_input": "* Line 1: Two space-separated integers: N and C", "test_output": "* Line 1: One integer: the largest minimum distance", "demo_input": "5 3\r\n1\r\n2\r\n8\r\n4\r\n9", "demo_output": "3"}
{"test_title": "019:A Knight's Journey", "test_describe": null, "test_input": "The input begins with a positive integer n in the first line. The following lines contain n test cases. Each test case consists of a single line with two positive integers p and q, such that 1 <= p * q <= 26. This represents a p * q chessboard, where p describes how many different square numbers 1, . . . , p exist, q describes how many different square letters exist. These are the first q letters of the Latin alphabet: A, . . .", "test_output": "The output for every scenario begins with a line containing \"Scenario #i:\", where i is the number of the scenario starting at 1. Then print a single line containing the lexicographically first path that visits all squares of the chessboard with knight moves followed by an empty line. The path should be given on a single line by concatenating the names of the visited squares. Each square name consists of a capital letter followed by a number.", "demo_input": "3\r\n1 1\r\n2 3\r\n4 3", "demo_output": "Scenario #1:\r\nA1\r\n\r\nScenario #2:\r\nimpossible\r\n\r\nScenario #3:\r\nA1B3C1A2B4C2A3B1C3A4B2C4\r\n"}
{"test_title": "012:拦截导弹", "test_describe": null, "test_input": "输入有两行，", "test_output": "输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。", "demo_input": "8\r\n300 207 155 300 299 170 158 65\r\n", "demo_output": "6\r\n"}
